package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/fatih/color"
	"github.com/spf13/cobra"

	"gothicforge/internal/execx"
)

var addPageCmd = &cobra.Command{
	Use:   "page <name>",
	Short: "Scaffold a new Templ page and SSG registration",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		raw := args[0]
		name := sanitizeKebab(raw)
		if name == "" {
			return fmt.Errorf("invalid page name: %q", raw)
		}
		comp := toPascal(name)

		// 1) Create Templ file under app/templates/<name>.templ
		tDir := filepath.Join("app", "templates")
		if err := os.MkdirAll(tDir, 0o755); err != nil {
			return err
		}
		tPath := filepath.Join(tDir, name+".templ")
		if _, err := os.Stat(tPath); err == nil {
			return fmt.Errorf("template already exists: %s", tPath)
		}
		tmpl := fmt.Sprintf(`package templates

// %s is a scaffolded page. Customize freely.
templ %s() {
    @LayoutSEO(SEO{
        Title:       "%s",
        Description: "",
        Canonical:   "/%s",
    }) {
        <div class="mx-auto max-w-7xl px-4 md:px-6">
            <section class="pt-16 pb-12 md:pt-20 md:pb-16">
                <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight">%s</h1>
                <p class="mt-4 opacity-80">This page was generated by gforge add page.</p>
            </section>
        </div>
    }
}
`, comp, comp, comp, name, comp)
		if err := os.WriteFile(tPath, []byte(tmpl), 0o644); err != nil {
			return err
		}

		// 2) Register in SSG so `gforge export` can include it automatically
		sDir := filepath.Join("app", "ssg")
		if err := os.MkdirAll(sDir, 0o755); err != nil {
			return err
		}
		sPath := filepath.Join(sDir, "register_"+name+".go")
		if _, err := os.Stat(sPath); err == nil {
			color.Yellow("SSG registration already exists: %s", sPath)
		} else {
			ssgGo := fmt.Sprintf(`package ssg

import (
    "github.com/a-h/templ"
    "gothicforge/app/templates"
)

func init() {
    Register("/%s", ToHTMLFunc(func() templ.Component { return templates.%s() }))
}
`, name, comp)
			if err := os.WriteFile(sPath, []byte(ssgGo), 0o644); err != nil {
				return err
			}
		}

		// 3) Run a one-shot templ generate so the new component compiles
		// Allow skipping in tests via GFORGE_SKIP_TEMPL=1
		skipTempl := strings.EqualFold(os.Getenv("GFORGE_SKIP_TEMPL"), "1") || strings.EqualFold(os.Getenv("GFORGE_SKIP_TEMPL"), "true")
		if !skipTempl {
			if templPath, err := ensureTool("templ", "github.com/a-h/templ/cmd/templ@latest"); err == nil {
				_ = execx.Run(cmd.Context(), "templ generate", templPath, "generate", "-include-version=false", "-include-timestamp=false")
			} else {
				color.Yellow("templ not available and auto-install failed: %v", err)
			}
		}

		// 4) Create a dedicated route registrant using routes.RegisterRoute
		rDir := filepath.Join("app", "routes")
		if err := os.MkdirAll(rDir, 0o755); err != nil {
			return err
		}
		rPath := filepath.Join(rDir, name+"_route.go")
		if _, err := os.Stat(rPath); err == nil {
			color.Yellow("Route registrant already exists: %s", rPath)
		} else {
			routeGo := fmt.Sprintf(`package routes

import (
    "github.com/gofiber/fiber/v2"
    "gothicforge/app/templates"
)

func init() {
    RegisterRoute(func(app *fiber.App) {
        app.Get("/%s", func(c *fiber.Ctx) error {
            c.Type("html")
            return templates.%s().Render(c.UserContext(), c.Response().BodyWriter())
        })
    })
}
`, "%s", "%s")
			routeGo = fmt.Sprintf(routeGo, name, comp)
			if err := os.WriteFile(rPath, []byte(routeGo), 0o644); err != nil {
				return err
			}
			// best-effort format
			_ = execx.Run(cmd.Context(), "gofmt", "gofmt", "-w", rPath)
			color.Green("✔ Added route registrant for /%s in %s", name, rPath)
		}

		color.Green("✔ Created %s", tPath)
		color.Green("✔ Updated %s", sPath)
		return nil
	},
}

func init() {
	addCmd.AddCommand(addPageCmd)
}

func sanitizeKebab(s string) string {
	s = strings.ToLower(s)
	re := regexp.MustCompile(`[^a-z0-9\-]+`)
	s = re.ReplaceAllString(s, "-")
	s = strings.Trim(s, "-")
	return s
}

func toPascal(kebab string) string {
	parts := strings.Split(kebab, "-")
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

// Note: no wireRoute needed; routes are registered via per-page registrants.
